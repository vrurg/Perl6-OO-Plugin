<!doctype html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8" />
        <style>
        kbd { font-family: "Droid Sans Mono", "Luxi Mono", "Inconsolata", monospace }
        samp { font-family: "Terminus", "Courier", "Lucida Console", monospace }
        u { text-decoration: none }
        .nested {
            margin-left: 3em;
        }
        aside, u { opacity: 0.7 }
        a[id^="fn-"]:target { background: #ff0 }
        </style>
        <link rel="stylesheet" href="//design.perl6.org/perl.css">
        
        
    </head>
    <body class="pod">
    <div id="___top"></div>
    
    
    
    <nav class="indexgroup">
<table id="TOC">
<caption><h2 id="TOC_Title">Table of Contents</h2></caption>
<tr class="toc-level-1"><td class="toc-number">1</td><td class="toc-text"><a href="#PREFACE">PREFACE</a></td></tr>
    <tr class="toc-level-1"><td class="toc-number">2</td><td class="toc-text"><a href="#INTRODUCTION">INTRODUCTION</a></td></tr>
       <tr class="toc-level-1"><td class="toc-number">3</td><td class="toc-text"><a href="#DESCRIPTION">DESCRIPTION</a></td></tr>
 <tr class="toc-level-2"><td class="toc-number">3.1</td><td class="toc-text"><a href="#Basics">Basics</a></td></tr>
                             <tr class="toc-level-2"><td class="toc-number">3.2</td><td class="toc-text"><a href="#Pre-loading_Plugins_And_Naming.">Pre-loading Plugins And Naming.</a></td></tr>
                    <tr class="toc-level-2"><td class="toc-number">3.3</td><td class="toc-text"><a href="#Ordering_And_Priorities">Ordering And Priorities</a></td></tr>
                                                                 <tr class="toc-level-3"><td class="toc-number">3.3.1</td><td class="toc-text"><a href="#Sorting">Sorting</a></td></tr>
                                                <tr class="toc-level-3"><td class="toc-number">3.3.2</td><td class="toc-text"><a href="#How_Ordering_Is_Used?">How Ordering Is Used?</a></td></tr>
  <tr class="toc-level-2"><td class="toc-number">3.4</td><td class="toc-text"><a href="#Writing_A_Plugin">Writing A Plugin</a></td></tr>
                      <tr class="toc-level-3"><td class="toc-number">3.4.1</td><td class="toc-text"><a href="#Method_Handling">Method Handling</a></td></tr>
                                         <tr class="toc-level-4"><td class="toc-number">3.4.1.1</td><td class="toc-text"><a href="#Method_Return_Value">Method Return Value</a></td></tr>
                        <tr class="toc-level-4"><td class="toc-number">3.4.1.2</td><td class="toc-text"><a href="#Chain_Control">Chain Control</a></td></tr>
                         <tr class="toc-level-4"><td class="toc-number">3.4.1.3</td><td class="toc-text"><a href="#Parametrized_Handlers">Parametrized Handlers</a></td></tr>
                                 <tr class="toc-level-4"><td class="toc-number">3.4.1.4</td><td class="toc-text"><a href="#Performance_Matters">Performance Matters</a></td></tr>
    <tr class="toc-level-3"><td class="toc-number">3.4.2</td><td class="toc-text"><a href="#Class_Overriding">Class Overriding</a></td></tr>
                                                  <tr class="toc-level-3"><td class="toc-number">3.4.3</td><td class="toc-text"><a href="#Callbacks">Callbacks</a></td></tr>
                                       <tr class="toc-level-3"><td class="toc-number">3.4.4</td><td class="toc-text"><a href="#Events">Events</a></td></tr>
                   <tr class="toc-level-4"><td class="toc-number">3.4.4.1</td><td class="toc-text"><a href="#Nuances">Nuances</a></td></tr>
                <tr class="toc-level-2"><td class="toc-number">3.5</td><td class="toc-text"><a href="#Plugin_META">Plugin META</a></td></tr>
                                                   <tr class="toc-level-2"><td class="toc-number">3.6</td><td class="toc-text"><a href="#Pluggables">Pluggables</a></td></tr>
                <tr class="toc-level-1"><td class="toc-number">4</td><td class="toc-text"><a href="#SEE_ALSO">SEE ALSO</a></td></tr>
     
</table>
</nav>

    <div class="pod-body">
    <h1 id="PREFACE"><a class="u" href="#___top" title="go to top of document">PREFACE</a></h1>
<p>This document is provinding the reader with in-depth explanation of how <code>OO::Plugin</code> framework works. Technical details are provided in respective modules.</p>
<h1 id="INTRODUCTION"><a class="u" href="#___top" title="go to top of document">INTRODUCTION</a></h1>
<p>This framework is intended to provide a mechanizm of extending an application functionality through use of third-party provided plugins. The following functionality is provided for a plugin:</p>
<ul><li><p>Method call handling for the purposes ranging from simply monitoring a method call to completely replacing the original method functionality with plug-provided one.</p>
</li>
<li><p>Class overriding using inheritance. I.e. an arbitrary core class can be inherited by a plugin-provided class and used by the core code instead of the original.</p>
</li>
<li><p>Flexible callbacks.</p>
</li>
<li><p>Asynchronous events.</p>
</li>
</ul>
<p>Also supported are automatic plugin module loading, and managing of plugin dependencies and priorities.</p>
<h1 id="DESCRIPTION"><a class="u" href="#___top" title="go to top of document">DESCRIPTION</a></h1>
<h2 id="Basics"><a class="u" href="#___top" title="go to top of document">Basics</a></h2>
<p>All work is done through a plugin manager. It is generally recommended to have a single instance of plugin manager per application. The application, in turn, is supposed to delegate it&#39;s object creation functionality to the manager. I.e., where usually we create an instance with this line of code:</p>
<pre class="pod-block-code">my $foo = Foo.new( attr =&gt; &#39;a value&#39; );</pre>
<p>it is now recommended to have this:</p>
<pre class="pod-block-code">my $foo = $plugin-manager.create( Foo, attr =&gt; &#39;a value&#39; );</pre>
<p>Alternatively, if one needs a class to work with but still capable of supporting plugins, he can do the following:</p>
<pre class="pod-block-code">my \foo-class = $plugin-manager.class( Foo );</pre>
<p>What happens under the hood is that the manager takes your class, considers what plugins are requesting to modify its behavior, and then creates a new class for you which will delegate some of its functionality to the plugins. This is somewhat simplified description of what is happening but it is only intended to explain why the delegation is necessary.</p>
<p>All the above also means that the creation of a plugin manager object is one of the first thing an application must do before anything else. Typically, the code would look like this:</p>
<p>class MyApp { has OO::Plugin::Manager $!plugin-manager;</p>
<pre class="pod-block-code">submethod TWEAK {
    $!plugin-manager .= new( base =&gt; &#39;MyApp&#39; );
    $!plugin-manager.load-plugins;
    $!plugin-manager.initialize( app =&gt; self );
}</pre>
<p>}</p>
<p>Of these three steps invocation of the <code>load-plugins</code> method is optional. This is where automatic pre-loading of plugins from external modules is happening. Refer to corresponding section below to find out more about this process.</p>
<p>By invocing <code>initialize</code> we actually make the manager ready to do its job. The point for having all these stages is to allow an application to perfom some extra additional steps before plugins are activated. Those are:</p>
<ul><li><p>disabling unwanted plugins</p>
</li>
<li><p>defining plugin priorities and, possibly, desired order of the plugins</p>
</li>
</ul>
<p>Future versions of the framework may have some additional functionality and this more things could be done before we start using the manager.</p>
<p><strong>NOTE</strong> <em>Though plugin disabling and changes to the ordering are not prohibited after the manager is initialized, they&#39;re not recommended due to possible unwanted side effect. Moreover, ordering is only done while manager is initializing.</em></p>
<p>A thing in the above code which worth mentioning here is the parameters to the <code>initialize</code> method call. The method itself doesn&#39;t take any. Whatever it receives is getting passed to the constructors of newly created plugin objects (this subject will be covered later). In my code what happens is that application object informs its plugins about itself allowing direct interaction between plugins and the application. By providing special API an application could get even more from its plugins that what is covered by the manager. Consider the following sample plugin:</p>
<pre class="pod-block-code">plugin MyPlugin {
    has MyApp:D $.app is required;

    submethod TWEAK (|) {
        $.app.register-macro( &quot;some_macro&quot;, self.^find_method(&#39;my-macro&#39;) );
    }

    method my-macro ( $param ) { &quot;$param is now expanded&quot; }
}</pre>
<p>Whatever other extensible subsystem is provided by application is then left up to the application and its plugins, the manager is not involved and thus leaves more space for developer&#39;s imagination.</p>
<h2 id="Pre-loading_Plugins_And_Naming."><a class="u" href="#___top" title="go to top of document">Pre-loading Plugins And Naming.</a></h2>
<p>When the manager is created it&#39;s <code>base</code> attribute can be defined. This attribute defines a namespace prefix to be used when looking for plugins in external modules. For the example above the manager will try to load all modules with names starting with <em>MyApp::Plugin::</em> or <em>MyApp::Plugins::</em>. Upon loading all classes contained in these modules and defined using <code>plugin</code> keyword will register themselves with the framework. This allows a single module to define more than one plugin:</p>
<pre class="pod-block-code">unit module MyApp::Plugins::MySet;

plugin Plugin1 {
    ...
}

plugin Plugin2 {
    ...
}</pre>
<p>As a result of compiling this module the framework will know about two new plugins <code>Plugin1</code> and <code>Plugin2</code>. Yet, it must be noted that though we&#39;re referring to them here with their short names, the framework will know them by their fully qualified names (FQN): <code>MyApp::Plugins::MySet::Plugin1</code> and <code>MyApp::Plugins::MySet::Plugin2</code>. This is to prevent name clashes when accidentally plugins from different packages are given same names.</p>
<h2 id="Ordering_And_Priorities"><a class="u" href="#___top" title="go to top of document">Ordering And Priorities</a></h2>
<p>It is possible for a two more plugins to be handling same method, class, or callback. In this case it becomes very important to define the order in which their respective handlers are used. When ordering plugins the manager takes into consideration a couple of plugin attributes such as:</p>
<ul><li><p>user-defined priority</p>
</li>
<li><p>user-defined ordering</p>
</li>
<li><p>plugin-declared dependencies</p>
</li>
</ul>
<p>Priorities could be of three different levels: <em>first</em>, <em>normal</em>, and <em>last</em>. Their names suggest that user wants a plugin to be one of the first in the list, one of the last, or in the middle. The latter is the default.</p>
<p>Within each priority a user can define in what particular order he wants the plugins. For example, lets say we have plugins <em>P1</em>, <em>P2</em>, <em>P3</em>, and <em>P4</em> – all assigned with <em>first</em> priority. Additionally, the user specifies that he wants <em>P2</em> to go after <em>P3</em>. In this case the manager will attempt to arrange plugins in a way, that <em>P3</em> will go first, then followed by <em>P2</em>, then by <em>P1</em> and <em>P4</em> in no particular order. Then these four will be followed by plugins with lower priorities.</p>
<p>To simplify user&#39;s life we don&#39;t want to make it his responsibility to find out if a <em>Plugin1</em> only works if it follows, say, <em>Plugin2</em>. The framework lets a plugin define these kinds of relations. More than that, it is also possible to specify wether the relation is desirable or it is demanded. Consider the followin code:</p>
<pre class="pod-block-code">plugin Plugin1 after Plugin2 before Plugin3 demands Plugin4, Plugin5 {
    ...
}</pre>
<p>Though rather unlikely to be met in real life, this code demonstrates what can be specified for a plugin. Here traits <code>after</code> and <code>before</code> (<strong>note</strong> that <code>before</code> is just a reverse of <code>after</code>. I.e. <code>Plugin1 before Plugin2</code> is the same as <code>Plugin2 after Plugin1</code>) define desirable relations. In other words, no fatalities would happen if these relations are broken. By &#39;broken&#39; we mean that either <em>Plugin2</em> or <em>Plugin3</em> are missing; or together with <em>Plugin1</em> and, possibly with some other plugins too, they form a circular dependency (see below about sorting).</p>
<p>On the other hand, <code>demand</code> means that if it can&#39;t be fulfilled then the only way to resolve the situation is to disable this plugin.</p>
<h3 id="Sorting"><a class="u" href="#___top" title="go to top of document">Sorting</a></h3>
<p>The manager will do its best to conform all the ordering parameters. But due to the complexity of the matter the only rule which can be taken for granted is:</p>
<ul><li><p><em>a demanded plugin will preceed the one which demands it</em></p>
</li>
<li><p><em>if a couple of plugins demanding each other form a cyclic dependency graph then all nodes of the graph will be disabled</em></p>
</li>
<li><p><em>if a plugin demands a disabled or missing plugin it will be disabled too</em></p>
</li>
</ul>
<p>All other relations, including user-defined, are considered voluntary. Though they&#39;re prioritized in the following order (from more prioritized down to less):</p>
<ul><li><p><code>after</code>/<code>before</code> relations</p>
</li>
<li><p>user order within priority</p>
</li>
<li><p>user-specified priority</p>
</li>
</ul>
<p>For example, if a <em>Plugin1</em> is of lowest <em>last</em> priority but is demanded by or must go before <em>Plugin2</em> which is of <em>first</em> priority – then <em>Plugin1</em> will go before <em>Plugin2</em> in the order no matter of their priorities.</p>
<p>As it was stated above, <code>after</code> and <code>before</code> doesn&#39;t impose strict requirements. For that matter if such dependencies form a cycle then manager has the right to break it at any link. For example, we have:</p>
<pre class="pod-block-code">A -&gt; B -&gt; C -&gt; D -&gt; A</pre>
<p>where arrow stands for <code>after</code>. The resulting order could be any of:</p>
<pre class="pod-block-code">A, D, C, B
B, A, D, C,
C, B, A, D
D, C, B, A</pre>
<p>It would only depend on what plugin is chosen first by the sorting algorithm to start building the sequence. With regard to the priorities, cicles might produce pretty surprising result: a plugin with higher priority will go last in the order! Say, specifying that <em>D</em> has the <em>first</em> priority while leaving all others at <em>normal</em> will result in the third sequence of the above example.</p>
<p>Also, because demanded relations are unbreakable, then when a cycle is formed of all <code>demand</code>s execpt for a single link the manager will predictably break that link, making it&#39;s left side element the first. For example, if <code>A -&gt; B</code> is the desired one whereas all the reast are demanding, then the final order will be:</p>
<pre class="pod-block-code">A, D, C, B</pre>
<h3 id="How_Ordering_Is_Used?"><a class="u" href="#___top" title="go to top of document">How Ordering Is Used?</a></h3>
<p>This will be covered in the section below.</p>
<h2 id="Writing_A_Plugin"><a class="u" href="#___top" title="go to top of document">Writing A Plugin</a></h2>
<p>A plugin is an instance of a class inheriting from a <code>Plugin</code> class defined in <a href="https://github.com/vrurg/Perl6-OO-Plugin/blob/v0.0.902/docs/md/OO/Plugin/Class.md">OO::Plugin::Class</a> module. To reduce the boilerplate and provide better readability of the code special class declarator <code>plugin</code> is provided:</p>
<pre class="pod-block-code">plugin MyPlugin {
    ...
}</pre>
<p>It is accompanied with three additional traits: <code>after</code>, <code>before</code>, and <code>demand</code>, each of them taking a list of plugin names:</p>
<pre class="pod-block-code">plugin MyPlugin after Plugin1, Plugin2, MyApp::Plugin::Plugin3 {
    ...
}</pre>
<p>As you can see, the names could be in both short and FQN forms. Their validity is not checked at the compile time because the order of loading of plugin modules cannot be pre-determined. Besides, since <code>after</code> and <code>before</code> are not strict missing a plugin cannot be considered a error. For this reason, all the checks are preformed at run-time.</p>
<h3 id="Method_Handling"><a class="u" href="#___top" title="go to top of document">Method Handling</a></h3>
<p>A plugin can request to handle a public method call in an application class. This is not just call interception as one might expect but something bigger than that. Method handling allows a wide variety of tricks from simply monitoring method calls to completely substitute a method with own code (which is in fact the interception as I see it). It is also possible to mangle with the original method parameters and return value.</p>
<p>The method call process is split in three stages: <em>before</em> the call, <em>around</em> it, and <em>after</em>. Every stage has certain specific and its own purpose. We&#39;ll get to this later. For now what matters is that the manger considers each stage as a separate queue of routines to be executed. I call it <u>execution chain</u>. In a way, the original method is also considered as a member of the <em>around</em> chain, though a special one. The order of the routines is defined by the order of the plugins they belong to. For example:</p>
<pre class="pod-block-code">plugin Plugin1 {
    method around-bar1 ( $msg ) is plug-around(:MyClass&lt;bar&gt;) { ... }
}

plugin Plugin2 before Plugin1 {
    method around-bar2 ( $msg ) is plug-around(:MyClass&lt;bar&gt;) { ... }
}</pre>
<p><code>around-bar2</code> will gain control before <code>around-bar1</code> due to <code>before</code> trait defining the plugin order.</p>
<p><strong>NOTE</strong> I&#39;m not detailing the code itself in hope that it is self-explainable. Will carry on on syntax later anyway.</p>
<p>A special packet of information is passed to every method handler as the first method parameter. It is called <em>message</em> and it is an object of <code>MethodHandlerMsg</code> class. The object is presistent across one method call handling session and is being passed to each and every handler method. In addition to some technical information about the call, it contains two special attributes: <code>shared</code> and <code>private</code>. Those are read/write accessible and can be used by plugins to pass information between different handlers and stages.</p>
<ul><li><p><code>shared</code> is a hash which is kept unchanged by the manager and therefore allows for some data exchange between method handlers from different plugins within the current handling session.</p>
</li>
<li><p><code>private</code> is somewhat similar to <code>shared</code> except that it is a unique value being kept for each plugin separately. It only allows a plugin to store a value across stages of the same handling session. <code>private</code> is a scalar and its content is solely defined by what a plugin code stores in it.</p>
</li>
</ul>
<p>For example:</p>
<pre class="pod-block-code">plugin Plugin1 {
    method before-bar ( $msg ) is plug-before(:MyClass&lt;bar&gt;) {
        $msg.private = &quot;info from &#39;before&#39;&quot;;
    }

    method after-bar ( $msg ) is plug-after(:MyClass&lt;bar&gt;) {
        say $msg.private; # &quot;info from &#39;before&#39;&quot;
    }
}</pre>
<h4 id="Method_Return_Value"><a class="u" href="#___top" title="go to top of document">Method Return Value</a></h4>
<p>Method handlers plugged into <em>around</em> or <em>after</em> stages can override the return value of a method. To do so they must set <code>rc</code> attribute or the message packet using <code>set-rc</code> method:</p>
<pre class="pod-block-code">plugin Plugin1 {
    method around-bar ( $msg ) is plug-around(:MyClass&lt;bar&gt;) {
        $msg.set-rc(&quot;my return&quot;);
    }
}</pre>
<p>For the <em>around</em> stage this action would a have a side-effect of preventing the original method from being executed.</p>
<p>The handlers of <em>after</em> stage can use the <code>rc</code> attribute of the message packet to inspect the return value (wherever it was set previously). They&#39;re also allowed to change it.</p>
<p>The <em>before</em> stage handlers are not allowed to set the return value. If they attempt to then a warning would be issued by the manager.</p>
<p><strong>NOTE</strong> The return value is not checked agains the original method&#39;s signature constraint if there is one.</p>
<h4 id="Chain_Control"><a class="u" href="#___top" title="go to top of document">Chain Control</a></h4>
<p>A method handler is capable of controlling the execution chain up to some extent. It can request the manager to either stop processing the chain right away or restart it from the beginning. Those actions are similar to <code>last</code> and <code>redo</code> commands available for controling the loops. Correspondingly, the framework provides <code>plug-last</code> and <code>plug-redo</code> for the convinience of a plugin writer. Behind the scenes special exceptions <code>CX::Plugin::Last</code> and <code>CX::Plugin::Redo</code> are utilized.</p>
<p>With <code>plug-last</code> <em>around</em> and <em>after</em> handlers can supply a single parameter to set the return value on the message packet.</p>
<p><code>plug-redo</code> must be used with care as it may cause an infinite loop. Next versions of this framework might impose a limit on the number of <code>redo</code>s emitted by a single plugin.</p>
<h4 id="Parametrized_Handlers"><a class="u" href="#___top" title="go to top of document">Parametrized Handlers</a></h4>
<p>The message object received by a handler has an attribute <code>params</code> which is a <code>Capture</code> of the orginal method parameters. Having a handler which is only deals with the message packet has an advantage of making it capable of handling multiple original methods in the most simple way. For example, the following code would record all calls of all methods of <code>MyClass</code>:</p>
<pre class="pod-block-code">plugin Recorder {
    method bind-them-all ( $msg ) is plug-before( &#39;MyClass&#39; ) {
        say $msg.method, &quot; with &quot;, $msg.params;
    }
}</pre>
<p>But this isn&#39;t really handy when one actually needs to have access to the parameters. Of course, there are a couple of ways to destructure a <code>Capture</code> object, but that adds to the complexity of the code - something I always want to avoid. For this reason, there is a simpler solution. If the plugin manager sees more than one parameter in the handler signature it passes the orignal method parameters next to the message packet object:</p>
<pre class="pod-block-code">class MyClass {
    method bar ( Int:D $i ) {
        return -$i
    }
}

plugin Plugin1 {
    method before-bar ( $msg, Int:D $i ) is plug-before(:MyClass&lt;bar&gt;) {
        say &quot;bar() with Int: $i&quot;;
    }
}

OO::Plugin::Manager.new.create( MyClass ).bar( 42 ); # bar() with Int: 42</pre>
<p><strong>NOTE</strong> For speeding up operations parameters are not checked against handler signature by the plugin manager code.</p>
<p><strong>NOTE</strong> The framework checks for the handler signature validity by inspecting its first parameter. It has to be a scalar (i.e. has <code>$</code> sigil) and be of type <code>Any</code>. It would better bet <code>MethodHandlerMsg</code> but due to a bug in Perl6 this is not possible for now because it causes an internal error.</p>
<p>Same rule apply to multi-dispatch method handlers where the <code>plug-</code> traits are to be applied to the <code>proto</code>:</p>
<pre class="pod-block-code">plugin Plugin1 {
    proto method around-bar ( $msg ) is plug-around(:MyClass&lt;bar&gt;) {*}
    multi method around-bar ( $msg ) { ... }

    proto method before-bar ( $msg, | ) is plug-before(:MyClass&lt;bar&gt;) {*}
    multi method before-bar ( $msg, Int:D $i ) { ... }
}</pre>
<p><strong>NOTE</strong> Currently it is possible to apply the trait to one of a <code>multi</code> variants within multi-dispatch. Doing so is highly discouraged and will be a error at some point in the future!</p>
<h4 id="Performance_Matters"><a class="u" href="#___top" title="go to top of document">Performance Matters</a></h4>
<p>It must be noted that method handling while being very powerful and flexible tool is pretty costly performance-wise. For speed-sensitive applications consider using <a href="#Class_Overriding">Class Overriding</a>.</p>
<h3 id="Class_Overriding"><a class="u" href="#___top" title="go to top of document">Class Overriding</a></h3>
<p>This is a very straightforward method of providing extended or altered functionality for your core. Whenever necessary a plugin can declare a so called <code>plug-class</code> which will inherit from a core class:</p>
<pre class="pod-block-code">use OO::Plugin;
use OO::Plugin::Manager;

class MyClass {
    method foo ( Str $s ) {
        S:g/\s/_/ given $s
    }
}

plugin Plugin1 {
    plug-class MyPlug for MyClass {
        method foo ( Str $s ) {
            callwith( &quot;my prefix for $s&quot; );
        }
    }
}

my $mgr = OO::Plugin::Manager.new.initialize;
my $inst = $mgr.create( MyClass );
say $inst.foo(&quot;1 2 3&quot;);                             # my_prefix_for_1_2_3
say $inst.^mro;                                     # ((MyClass_4jN3Lv) (MyPlug_YHNAfr) (MyClass) (Any) (Mu))</pre>
<p><em>Note</em> that the output of the last line is a sample. The last six chars following the underscore char are random.</p>
<p>Let me explain the magic behind this code. Actually, <code>plug-class</code> doesn&#39;t declare a class. It declares a role (<em>they&#39;re certain limitations in Rakudo making this the only possible way</em>). For each <code>plug-class</code> defined for the requested core class (<code>MyClass</code> in the example) the manager generates an empty class and apply the <code>plug-class</code> role to it. Then it sets a parent for the new class (not necessarily it is the core class as more than one plugin is defining a <code>plug-class</code> for it). Eventually, a new class is generated which inherits from the newly created inheritance chain.</p>
<p>This result of the alogirth can be observed in the output of <code>.^mro</code>. Say, if we add another plugin to the above code:</p>
<pre class="pod-block-code">plugin Plugin2 before Plugin1 {
    plug-class MyPlug2 for MyClass {
        ...
    }
}</pre>
<p>The resulting chain would then look like this:</p>
<pre class="pod-block-code">((MyClass_4jN3Lv) (MyPlug2_NjJk1a) (MyPlug_YHNAfr) (MyClass) (Any) (Mu))</pre>
<p>Note that <code>Plugin2</code> is declaring to go <em>before</em> <code>Plugin1</code> - so goes <code>MyPlug2</code> before <code>MyPlug</code> in the MRO. This is how plugin ordering works for class overriding.</p>
<p>As <code>plug-class</code> is a role in nature, so all of the role limitations apply. For example, a role cannot have <code>our</code> declarations. Most of those limitations could be overcome by using <code>plugin</code>&#39;s body:</p>
<pre class="pod-block-code">plugin Plugin1 {
    out $plug-class-variable;

    plug-class MyPlug for MyClass {
        method foo {
            say $plug-class-variable;
        }
    }
}</pre>
<p>A <code>plug-class</code> doesn&#39;t have direct access to the plugin object of his respective <code>plugin</code> though. But the object can be obtained with the plugin manager API.</p>
<h3 id="Callbacks"><a class="u" href="#___top" title="go to top of document">Callbacks</a></h3>
<p><u>Callback</u> is a way of calling a special method of a plugin and getting a return value from it. A callback is defined by a string name and can further be detailed with method signature.</p>
<p>Callback is the most simple and straightforward way of direct interaction between application code and plugins: a plugin defines a multi-method <code>on-callback</code>:</p>
<pre class="pod-block-code">plugin Plugin1 {
    multi method on-callback ( &#39;my-callback&#39;, $msg, Str $p1, Int $p2 ) {
        ...
        return &quot;The Universe&quot;;
    }
}</pre>
<p>Then application issue a call:</p>
<pre class="pod-block-code">my $mgr = OO::Plugin::Manager.new;
...
say $mgr.callback( &#39;my-callback&#39;, &quot;the answer&quot;, 42 ); # The Universe</pre>
<p>and it gets dispatched to matching <code>on-callback</code> methods of all plugins. This also implies that for any given callback the term <u>execution chain</u> defined in <a href="#Method_Handling">Method Handling</a> applies too, as well as the methods to control the chain using <code>plug-last</code> or <code>plug-redo</code> routines.</p>
<p>Similarly to method handling, a callback receives a message object of <code>PluginMessage</code> type. (<em>Actually, <code>PluginMessage</code> is the base class of <code>MethodHandlerMsg</code></em>) And same way, as for method handling, a callback can specify its return value using <code>set-rc</code> method of the object or by returning the value. In the latter case the value must be defined and not already set in any other manner (like by a previous callback in the chain) or it will be dropped by the manager. If a callback needs to return a type then this can only be done with <code>set-rc</code> or <code>plug-last</code>.</p>
<p>If a callback doesn&#39;t use <code>plug-last</code> to indicate the termination of the execution chain, then any next callback from a later-located plugin can override it with own value using <code>set-rc</code> method of the message object.</p>
<h3 id="Events"><a class="u" href="#___top" title="go to top of document">Events</a></h3>
<p>Similarly to callbacks, <u>event</u> is a way of calling a special method of a plugin. Events are different in a way that they&#39;re handled asynchronously and are designed for mostly one-way communication: from application to plugins. Event is handled by a multi-method too:</p>
<pre class="pod-block-code">plugin Plugin1 {
    multi method on-event ( &#39;my-event&#39;, Str $p1, Int $p2 ) {
        ...
    }
}</pre>
<p>Contrary to other handler methods, it doesn&#39;t receive any special message object, as it is clear from the example.</p>
<p>On the application side, sending of an event is as simple as:</p>
<pre class="pod-block-code">my $mgr = OO::Plugin::Manager.new;
...
my $promise = $mgr.event( &#39;my-event;, &quot;the answer&quot;, 42 );</pre>
<p>The returned <code>Promise</code> will be kept when all event handlers are completed.</p>
<p>If there is more than one event handler with the same signature matching the passed parameters, then they will be executed in parallel. The number of simultaneously running handlers is limited by <code>event-workers</code> attribute of the plugin manager. Setting it to 1 will cause the handlers to be called one after another but still in a separate thread, so the main application code may proceed as usual.</p>
<p>Clearly, the plugin ordering doesn&#39;t apply to event handling; this neither execution chain is used. Therefore it is guaranteed that for every event all its matching handlers will be called.</p>
<p>To allow the handlers complete without interruption it is highly recommended for an application to call method <code>finish</code> on the plugin manager object before exiting the application:</p>
<pre class="pod-block-code">$mgr.finish;</pre>
<h4 id="Nuances"><a class="u" href="#___top" title="go to top of document">Nuances</a></h4>
<ul><li><p>Events are dispatched by a special method in its own thread. To reduce resource consumption, it is not getting started until an event is sent by the application. It will also shutdown if no event is been sent over a timeout period. The timeout is defined by <code>ev-dispatcher-timeout</code> attribute of the manager.</p>
</li>
<li><p>It is still possible to obtain return value of a particular event handler. The <code>Promise</code> returned by the <code>event</code> method is kept with an array of <code>Promise</code>s of each event handler. Those are being kept with two-element arrays where the first element is a plugin object, and the second is event handler return value.</p>
</li>
<li><p>If an event handler throws and exception it is silently consumed by the dispatcher. But the exception can be fetched from the second element of event handler&#39;s <code>Promise</code> where it will be stored instead of the return value.</p>
</li>
</ul>
<p><em><strong>NOTE</strong> Other methods of reporting errors back to the user code are considered. Any feedback is welcome!</em></p>
<h2 id="Plugin_META"><a class="u" href="#___top" title="go to top of document">Plugin META</a></h2>
<p>Any plugin has some meta-data attached to it. The format is as simple as it can be: it&#39;s a hash of meta-keys with values. There is no predefined set of keys. Any application can use any keys for its own purpose. Though a couple of keys are reserved for the plugin manager itself. Those are:</p>
<ul><li><p><code>version</code></p>
<p>Plugin version. Must be a <code>Version</code> object.</p>
</li>
<li><p><code>name</code></p>
<p>Plugin short name as the developer wants it to be. This allows to override short name obtained from plugin&#39;s module name. Both name can later be used to get FQN of the plugin.</p>
</li>
<li><p><code>after</code>, <code>before</code></p>
<p>Desirable ordering relations.</p>
</li>
<li><p><code>demand</code></p>
<p>Demanding <code>after</code> ordering relation.</p>
</li>
</ul>
<p>The meta is registered from within plugin&#39;s body block either with <code>plugin-meta</code> routine, or with <code>our %meta</code> hash:</p>
<pre class="pod-block-code">plugin Plugin1 {
    our %meta = key1 =&gt; &quot;value1&quot;,
                key2 =&gt; &quot;value2&quot;,
                key3 =&gt; 42,
                ;

    plugin-meta key1 =&gt; &quot;value 1&quot;,
                key4 =&gt; &quot;value 4&quot;,
                demand =&gt; &lt;Plugin2 Plugin3&gt;,
                ;
}</pre>
<p>For the same key <code>key1</code> the value from <code>plugin-meta</code> will take precedence. Generally speaking, the precedence of sources for the meta are:</p>
<ul><li><p>plugin declaration</p>
</li>
<li><p><code>plugin-meta</code></p>
</li>
<li><p><code>%meta</code></p>
</li>
</ul>
<p>Keys declared in higher priority override keys from lower priority source.</p>
<p><code>after</code>, <code>before</code>, and <code>demand</code> are keys which are taken special care. Those can be declared in the plugin declarion with traits of the same names. So, for the code:</p>
<pre class="pod-block-code">plugin Plugin1 after Plugin2 {
    our %meta = demand =&gt; &lt;Plugin5&gt;,
                before =&gt; &lt;Plugin6&gt;,

    plugin-meta after  =&gt; &lt;Plugin3&gt;,
                before =&gt; &lt;Plugin3&gt;,
                ;
}</pre>
<p>The final meta will be:</p>
<pre class="pod-block-code">after  =&gt; &lt;Plugin2&gt;, # from the declaration
before =&gt; &lt;Plugin3&gt;, # from plugin-meta
demand =&gt; &lt;Plugin5&gt;, # from %meta</pre>
<p><strong>NOTE</strong> Though the values above are strings, in real life ordering meta keys are <code>Set</code>s of plugin names.</p>
<p>Another meta key taken from plugin declaration is <code>version</code>:</p>
<pre class="pod-block-code">plugin Plugin1:ver&lt;0.1.0&gt; {
    ...
}</pre>
<p>unless there is manually defined <code>version</code> key declared by the programmer.</p>
<h2 id="Pluggables"><a class="u" href="#___top" title="go to top of document">Pluggables</a></h2>
<p>The framework provides a special trait <code>is pluggable</code> which is applicable to both classes and methods and marks those of them which the users wants to allow to be overriden. For example:</p>
<pre class="pod-block-code">class Foo is pluggable {
    ...
}

class Bar {
    ...
    method plug-me is pluggable {
        ...
    }
}</pre>
<p>The outcome of applying the trait differs depending on wether the plugin manager is in <em>strict</em> or <em>loose</em> mode. In the former it will raise an error for any attempt to override an unpluggable class or attach a handler to an unpluggable method. In the latter (which is the default) any class or method are considered pluggable.</p>
<p>A user can request a registry of pluggables from <a href="https://github.com/vrurg/Perl6-OO-Plugin/blob/v0.0.902/docs/md/OO/Plugin/Registry.md">OO::Plugin::Registry</a>. This information can be used, for example, to provide a plugin developer with the information about what objects are opened for &quot;suggestions&quot;.</p>
<p>Note though that in <em>loose</em> mode the manager will register any class or method requested by a plugin as pluggable. This functionality is considered experimental and might be a subject for change in the future.</p>
<h1 id="SEE_ALSO"><a class="u" href="#___top" title="go to top of document">SEE ALSO</a></h1>
<p><a href="https://github.com/vrurg/Perl6-OO-Plugin/blob/v0.0.902/docs/md/OO/Plugin.md">OO::Plugin</a>, <a href="https://github.com/vrurg/Perl6-OO-Plugin/blob/v0.0.902/docs/md/OO/Plugin/Manager.md">OO::Plugin::Manager</a>, <a href="https://github.com/vrurg/Perl6-OO-Plugin/blob/v0.0.902/docs/md/OO/Plugin/Class.md">OO::Plugin::Class</a></p>

    </div>
    
    
    </body>
</html>

